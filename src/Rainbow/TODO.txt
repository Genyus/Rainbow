// TODO: moving items changes the parent ID in teh index but not the path
// TODO: moving stuff around seems to occasionally delete items
// TODO: need a way to ignore moving descendants of moves to ignored paths in the predicate
	e.g. you move /foo/bar to /foot/bar. but /foot/bar/baz is on ignore list. the moved baz item should be deleted instead of moved. see movedescendants in the old serialization provider.
// TODO: 'default' root path semantic not supported
// TODO: unicorn reserialize does not delete existing gib folders
// TODO: work out dependencies handling (in general, also registering serialization formatters?)
// TODO: non-transactional provider for writing? with index flushing?
// TODO: field predicate-like functionality - maybe in SerializableItem as a dependency you can inject? (note: revision and such are being serialized now)
// TODO: formatting of security field values?
// TODO: extend unicorn data provider model to allow optional dp features like consistency checks, updating items with a field when deleting a t-field
// TODO: roles support
// TODO: file name shown in unicorn error messages appears to be incorrect
// TODO: what if we made the sitecore db into a serialization store, and allowed you to generically diff serialization stores?
	Could use that to diff serialization (for sitecore upgrades?), make update packages, etc
// TODO: file pathing organization - long paths, ID-based, oh my.
// TODO: what about implementing a separate diff engine that does the diff/comparison and generates a diff-list, which the deserializer could then pick up without recomparing?
	- that said, doing this would mean that the diff engine would need to be comprehensive to get time savings on deserialization
	- would enable "what if"
	- would enable other diff/merge scenarios other than Unicorn


Working architecture statements:
- Project splits into three major components
	- Rainbow (and Rainbow datastore types; at launch SitecoreDB and YAML, maybe Remoting) - generic storage APIs for serialized - or DB - or webservice - content. Any two datastores can be synced. Datastores know about deserialization. Datastores also know about security roles. Rainbow core knows about predicate filtering, as stores need to know about predicates when moving items.
	- Sync (as yet undefined) - a tool to compare two data stores and determine sync status (in Unicorn terms, imagine the sync engine + evaluator but without any writing only creating metadata). Also has a simple diff engine for security roles.
	- Unicorn - now a shell of its former self. contains data provider, UI elements for sync. Sync now calls the Sync lib, and performs field predicate filtering and deserialization handled by destination data store

- Futures
	- Tool to visualize the tree in any data store, remove items
	- Rhino reborn, using Rainbow as a universal backend and requiring no syncing. Maybe.

Pathing provider thoughts

- Naming things by ID - sounds good, but means item names are 35 char long which makes depth before path length too short (4-5 levels)
- Loopback by path length to a NEW TREE - sounds good; Sitecore puts each item on a hashpath, we restart the tree there, preserving hierarchy
	e.g. master/$/{guid}-RootItemName/child/item/foo.yml
	Note: can run into situation where some children of an item are short enough to fit and some go to long paths.
		This means we'd want to loopback to the PARENT ID and place the child within it - then traversing children is equal to native FS children + loopback root children if any

- What if we could organize by "snippet", removing the base paths from the equation? e.g. if serRoot is /sitecore/templates/Sites/MySite, root at "MySite" and ignore the rest
	Would save a lot of path length but would be a paradigm change from a 'data store'

- CHALLENGES:
	Same named items in same tree location. Gets ugly when keying filenames by something non unique.
	Sparse trees - e.g. /sitecore wont be actually in the store, but /sitecore/templates/Sites would be - traversal of whole tree with unknown parent nodes, hopefully without 'references'
	Moving and renaming items
	Efficient get item by ID
	Human readability
	Cleanup after deleting items (e.g. empty folders)